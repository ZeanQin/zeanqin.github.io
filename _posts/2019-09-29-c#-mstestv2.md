---
title: C# - Automated Testing with MSTest V2
layout: post
use_toc: true
excerpt: Unit test in C# using MSTest V2.
---

## The benefits of automated tests

- Find (and fix) errors sooner
- Free to execute as often as required
- Quick to execute (versus manual testing)
- Generally more repeatable (versus manual)
- Execution flexibility:
  - Run on demand
  - As part of continuous integration
  - On a schedule (e.g. overnight)

## MSTest Overview

The high level components of MSTest are:

- **Attributes** are used in the code to mark methods as test methods.
- **Asserts** allow us to check the expected values are received from the production code.
- **Test runners** look through the code, look for specific test attributes that mark methods as tests and execute those methods. It also reports the outcome of tests, for example, whether a test passed or failed. These can include free test runners and 3rd party commercial test runners. 

NuGet Packages

- `MSTest.TestFramework` includes,
  - Attributes,
  - Assert methods,
  - Data driven tests,
  - Extensibility points

- `MSTest.TestAdapter` allows us to,
  - discover MSTest-based tests such as `[TestMethod]` etc.,
  - execute tests

## Conventions

1. The test project should be named `<ProjectName>.Tests` where `<ProjectName>` is the name of the project that you are writing tests for.
2. Each test file and the class in it should be named as `<ClassName>Should.cs` and each test method name should describe the goal of the test such as `public void BeInExperiencedWhenNew() {}`

```csharp
[TestClass]
public class PlayerShould
{
   [TestMethod]
   public void BeInExpierencedWhenNew()
   {
      // ...
   }
}
```

## Asserts

The different types of asserts are,

- General purpose asserts, i.e. the static methods in `Assert`,
- Specialised string asserts, i.e. the static methods in `StringAssert`,
- Specialised collection asserts, i.e. the static methods in `CollectionAssert`
- Exception, type, and reference asserts
- Custom asserts

## Controlling and customising test execution

### Test categorisation

We can set a category on a test method or a test class. Multiple categories can be applied to a test method/class. When a category is set for a class, all test methods in that class are added to that category.

```csharp
[TestMethod]
[TestCategory("Player defaults")] // set a category for a test
[TestCategory("Another category")] // set a category for a test
public void BeInexperiencedWhenNew()
{

}
```

To run tests in a category, use `dotnet test --filter="TestCategory=Player defaults"`. To run tests in multiple categories, use `dotnet test --filter="TestCategory=Player defaults|TestCategory=Another category"`

To run tests in a class, use `dotnet test --filter="ClassName=<Namespace>.<ClassName>"`

### Ingore tests

Use the `Ignore` attribute to temporarily ignore a test method. 

```csharp
[TestMethod]
[Ignore("Because ... ")] // ignore test method with a reason
public void BeNice()
{
   // ...
}
```

### Output additional messages

We can use `Console.WriteLine()` inside test methods to output additional messages. To see the messages, run `dotnet run -v n`

### Run additional code during the test execution lifecycle

We can add additional methods that will be run automatically for us by MSTest. These methods can be used to run set up code or clean up code.

```csharp
[TestClass]
public class LifeCycle
{

   /*
   * Run this method before any test method in this assembly runs.
   *
   * The method has to be static and passes the TestContext object as parameter.
   */
   [AssemblyInitialize]
   public static void AssemblyInit(TestContext context) {}

   /*
   * Run this code only once before any test method runs.
   *
   * This method has to be static and accepts the TestContext object as parameter.
   */
   [ClassInitialize]
   public static void LifeCycleClassInit(TestContext context) {}

   /*
   * Run this code before each and every test method runs.
   */
   [TestInitialize]
   public void LifeCycleInit() {}

   /*
   * Run this test method after each and every test method runs.
   */
   [TestCleanup]
   public void LifeCycleInit() {}

   /*
   * Run this code after all test methods have finished running.
   *
   * This method has to be static and accepts the TestContext object as parameter.
   */
   [ClassCleanup]
   public static void LifeCycleClassInit(TestContext context) {}

   /*
   * Run this method after all test methods in this assembly have finished running.
   *
   * The method has to be static and passes the TestContext object as parameter.
   */
   [AssemblyCleanup]
   public static void AssemblyCleanup(TestContext context) {}

   [TestMethod]
   public void Test1() {}

   [TestMethod]
   public void Test2() {}
}
```

### Share object between tests

Some object might take a long time to create. We can create one object and share it between tests.

```csharp
[TestClass]
public class Foo
{
   static string SomeExpensiveObject;

   [ClassInitialize]
   public static void Bar(TestContext context)
   {
      SomeExpensiveOjbect = // create object
   }
}
```

## References

1. [TestCase filter](https://github.com/Microsoft/vstest-docs/blob/master/docs/filter.md)
