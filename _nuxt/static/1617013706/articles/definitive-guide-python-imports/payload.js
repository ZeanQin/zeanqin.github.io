__NUXT_JSONP__("/articles/definitive-guide-python-imports", (function(a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w,x,y,z,A,B,C,D,E,F,G,H,I,J,K,L,M,N,O,P,Q,R,S,T,U,V,W,X,Y,Z,_,$,aa,ab,ac,ad,ae,af,ag,ah,ai,aj,ak,al,am,an,ao,ap,aq,ar,as,at,au,av,aw,ax,ay,az,aA,aB,aC,aD,aE,aF,aG,aH,aI,aJ,aK,aL,aM,aN,aO,aP,aQ,aR,aS,aT,aU,aV,aW,aX,aY,aZ,a_,a$,ba,bb,bc,bd,be,bf,bg,bh,bi,bj,bk,bl,bm,bn,bo,bp,bq,br,bs,bt,bu,bv,bw,bx,by,bz,bA,bB,bC,bD,bE,bF,bG,bH,bI,bJ,bK,bL,bM,bN,bO,bP,bQ,bR,bS,bT,bU,bV,bW,bX,bY,bZ,b_,b$,ca,cb,cc,cd,ce,cf,cg,ch,ci,cj,ck,cl,cm,cn,co,cp,cq){return {data:[{article:{title:"The definitive guide to Python import statements",excerpt:"I've almost never been able to write correct Python `import` statements on the first go. Behavior is inconsistent between Python 2.7 and Python 3.6 (the two versions that I test here), and there is no single method for guaranteeing that imports will always work. This post is my dive into how to resolve common importing problems. Unless otherwise stated, all examples here work with both Python 2.7 and 3.6.",category:"Programming Language",tags:["Python","Import Statements"],createdAt:"2017-08-07T14:00:00.000Z",updatedAt:"2020-08-16T05:29:00.307Z",enableComments:aK,enableTOC:aK,toc:[{id:aL,depth:N,text:aM},{id:aN,depth:N,text:aO},{id:aP,depth:N,text:aQ},{id:aR,depth:N,text:"What is an import"},{id:aS,depth:N,text:"Basics of the Python import and sys.path"},{id:aT,depth:R,text:"More on sys.path"},{id:aU,depth:N,text:"All about __init__.py"},{id:aV,depth:R,text:aW},{id:aX,depth:R,text:aY},{id:aZ,depth:N,text:a_},{id:a$,depth:R,text:"Use dir() to examine the contents of an imported module"},{id:ba,depth:R,text:bb},{id:bc,depth:N,text:bd},{id:be,depth:N,text:bf},{id:bg,depth:R,text:"Case 1: sys.path is known ahead of time"},{id:bh,depth:R,text:"Case 2: sys.path could change"},{id:bi,depth:R,text:"Case 3: sys.path could change (take 2)"},{id:bj,depth:R,text:bk},{id:bl,depth:N,text:bm},{id:bn,depth:N,text:bo}],body:{type:"root",children:[{type:b,tag:_,props:{},children:[{type:a,value:d},{type:b,tag:g,props:{},children:[{type:b,tag:C,props:{},children:[{type:b,tag:F,props:{},children:[{type:a,value:"Note: I didn't create this post. The original author is "},{type:b,tag:j,props:{href:"https:\u002F\u002Fgithub.com\u002Fchrisyeh96\u002Fchrisyeh96.github.io",rel:[l,m,n],target:o},children:[{type:a,value:"here"}]},{type:a,value:k}]}]}]},{type:a,value:d}]},{type:a,value:d},{type:b,tag:O,props:{id:aL},children:[{type:b,tag:j,props:{href:"#summary--key-points",ariaHidden:u,tabIndex:v},children:[{type:b,tag:e,props:{className:[w,x]},children:[]}]},{type:a,value:aM}]},{type:a,value:d},{type:b,tag:t,props:{},children:[{type:a,value:d},{type:b,tag:i,props:{},children:[{type:b,tag:c,props:{},children:[{type:a,value:r}]},{type:a,value:" statements search through the list of paths in "},{type:b,tag:c,props:{},children:[{type:a,value:p}]}]},{type:a,value:d},{type:b,tag:i,props:{},children:[{type:b,tag:c,props:{},children:[{type:a,value:p}]},{type:a,value:" always includes the path of the script invoked on the command line and is agnostic to the working directory on the command line."}]},{type:a,value:d},{type:b,tag:i,props:{},children:[{type:a,value:"importing a package is conceptually the same as importing that package's "},{type:b,tag:c,props:{},children:[{type:a,value:y}]},{type:a,value:" file"}]},{type:a,value:d}]},{type:a,value:d},{type:b,tag:O,props:{id:aN},children:[{type:b,tag:j,props:{href:"#basic-definitions",ariaHidden:u,tabIndex:v},children:[{type:b,tag:e,props:{className:[w,x]},children:[]}]},{type:a,value:aO}]},{type:a,value:d},{type:b,tag:t,props:{},children:[{type:a,value:d},{type:b,tag:i,props:{},children:[{type:b,tag:C,props:{},children:[{type:a,value:"module"}]},{type:a,value:": any "},{type:b,tag:c,props:{},children:[{type:a,value:bp}]},{type:a,value:" file. Its name is the file name."}]},{type:a,value:d},{type:b,tag:i,props:{},children:[{type:b,tag:C,props:{},children:[{type:a,value:"built-in module"}]},{type:a,value:": a \"module\" (written in C) that is compiled into the Python interpreter, and therefore does not have a "},{type:b,tag:c,props:{},children:[{type:a,value:bp}]},{type:a,value:bq}]},{type:a,value:d},{type:b,tag:i,props:{},children:[{type:b,tag:C,props:{},children:[{type:a,value:"package"}]},{type:a,value:": any folder containing a file named "},{type:b,tag:c,props:{},children:[{type:a,value:y}]},{type:a,value:" in it. Its name is the name of the folder."},{type:b,tag:t,props:{},children:[{type:a,value:d},{type:b,tag:i,props:{},children:[{type:a,value:"in Python 3.3 and above, any folder (even without a "},{type:b,tag:c,props:{},children:[{type:a,value:y}]},{type:a,value:" file) is considered a package"}]},{type:a,value:d}]}]},{type:a,value:d},{type:b,tag:i,props:{},children:[{type:b,tag:C,props:{},children:[{type:a,value:"object"}]},{type:a,value:": in Python, almost everything is an object - functions, classes, variables, etc."}]},{type:a,value:d}]},{type:a,value:d},{type:b,tag:O,props:{id:aP},children:[{type:b,tag:j,props:{href:"#example-directory-structure",ariaHidden:u,tabIndex:v},children:[{type:b,tag:e,props:{className:[w,x]},children:[]}]},{type:a,value:aQ}]},{type:a,value:d},{type:b,tag:H,props:{className:[I]},children:[{type:b,tag:J,props:{className:[K,br]},children:[{type:b,tag:c,props:{},children:[{type:a,value:"test\u002F                      # root folder\n    packA\u002F                 # package packA\n        subA\u002F              # subpackage subA\n            __init__.py\n            sa1.py\n            sa2.py\n        __init__.py\n        a1.py\n        a2.py\n    packB\u002F                 # package packB (implicit namespace package)\n        b1.py\n        b2.py\n    math.py\n    random.py\n    other.py\n    start.py\n"}]}]}]},{type:a,value:d},{type:b,tag:g,props:{},children:[{type:a,value:"Note that we do not place a "},{type:b,tag:c,props:{},children:[{type:a,value:y}]},{type:a,value:" file in our root "},{type:b,tag:c,props:{},children:[{type:a,value:D}]},{type:a,value:bs}]},{type:a,value:d},{type:b,tag:O,props:{id:aR},children:[{type:b,tag:j,props:{href:"#what-is-an-import",ariaHidden:u,tabIndex:v},children:[{type:b,tag:e,props:{className:[w,x]},children:[]}]},{type:a,value:"What is an "},{type:b,tag:c,props:{},children:[{type:a,value:r}]}]},{type:a,value:d},{type:b,tag:g,props:{},children:[{type:a,value:"When a module is imported, Python runs all of the code in the module file. When a package is imported, Python runs all of the code in the package's "},{type:b,tag:c,props:{},children:[{type:a,value:y}]},{type:a,value:" file, if such a file exists. All of the objects defined in the module or the package's "},{type:b,tag:c,props:{},children:[{type:a,value:y}]},{type:a,value:" file are made available to the importer."}]},{type:a,value:d},{type:b,tag:O,props:{id:aS},children:[{type:b,tag:j,props:{href:"#basics-of-the-python-import-and-syspath",ariaHidden:u,tabIndex:v},children:[{type:b,tag:e,props:{className:[w,x]},children:[]}]},{type:a,value:"Basics of the Python "},{type:b,tag:c,props:{},children:[{type:a,value:r}]},{type:a,value:P},{type:b,tag:c,props:{},children:[{type:a,value:p}]}]},{type:a,value:d},{type:b,tag:g,props:{},children:[{type:a,value:"According to Python documentation, here is how an "},{type:b,tag:c,props:{},children:[{type:a,value:r}]},{type:a,value:" statement searches for the correct module or package to import:"}]},{type:a,value:d},{type:b,tag:_,props:{},children:[{type:a,value:d},{type:b,tag:g,props:{},children:[{type:a,value:"When a module named "},{type:b,tag:c,props:{},children:[{type:a,value:bt}]},{type:a,value:" is imported, the interpreter first searches for a built-in module with that name. If not found, it then searches for a file named "},{type:b,tag:c,props:{},children:[{type:a,value:bu}]},{type:a,value:" in a list of directories given by the variable "},{type:b,tag:c,props:{},children:[{type:a,value:p}]},{type:a,value:bv},{type:b,tag:c,props:{},children:[{type:a,value:p}]},{type:a,value:" is initialized from these locations:"}]},{type:a,value:d},{type:b,tag:t,props:{},children:[{type:a,value:d},{type:b,tag:i,props:{},children:[{type:a,value:"The directory containing the input script (or the current directory when no file is specified)."}]},{type:a,value:d},{type:b,tag:i,props:{},children:[{type:b,tag:c,props:{},children:[{type:a,value:Y}]},{type:a,value:" (a list of directory names, with the same syntax as the shell variable PATH)."}]},{type:a,value:d},{type:b,tag:i,props:{},children:[{type:a,value:"The installation-dependent default."}]},{type:a,value:d}]},{type:a,value:d},{type:b,tag:g,props:{},children:[{type:a,value:"After initialization, Python programs can modify "},{type:b,tag:c,props:{},children:[{type:a,value:p}]},{type:a,value:". The directory containing the script being run is placed at the beginning of the search path, ahead of the standard library path. This means that scripts in that directory will be loaded instead of modules of the same name in the library directory.\n"},{type:b,tag:F,props:{},children:[{type:a,value:aj},{type:b,tag:j,props:{href:"https:\u002F\u002Fdocs.python.org\u002F2\u002Ftutorial\u002Fmodules.html#the-module-search-path",rel:[l,m,n],target:o},children:[{type:a,value:Q}]},{type:a,value:P},{type:b,tag:j,props:{href:"https:\u002F\u002Fdocs.python.org\u002F3\u002Ftutorial\u002Fmodules.html#the-module-search-path",rel:[l,m,n],target:o},children:[{type:a,value:S}]}]}]},{type:a,value:d}]},{type:a,value:d},{type:b,tag:g,props:{},children:[{type:a,value:"Technically, Python's documentation is incomplete. The interpreter will not only look for a "},{type:b,tag:F,props:{},children:[{type:a,value:"file"}]},{type:a,value:" (i.e. module) named "},{type:b,tag:c,props:{},children:[{type:a,value:bu}]},{type:a,value:", it will also look for a "},{type:b,tag:F,props:{},children:[{type:a,value:"folder"}]},{type:a,value:" (i.e. package) named "},{type:b,tag:c,props:{},children:[{type:a,value:bt}]},{type:a,value:k}]},{type:a,value:d},{type:b,tag:g,props:{},children:[{type:a,value:"Note that the Python interpreter first searches through the list of "},{type:b,tag:F,props:{},children:[{type:a,value:"built-in modules"}]},{type:a,value:", modules that are compiled directly into the Python interpreter. This list of built-in modules is installation-dependent and can be found in "},{type:b,tag:c,props:{},children:[{type:a,value:"sys.builtin_module_names"}]},{type:a,value:bw},{type:b,tag:j,props:{href:"https:\u002F\u002Fdocs.python.org\u002F2\u002Flibrary\u002Fsys.html#sys.builtin_module_names",rel:[l,m,n],target:o},children:[{type:a,value:Q}]},{type:a,value:P},{type:b,tag:j,props:{href:"https:\u002F\u002Fdocs.python.org\u002F3\u002Flibrary\u002Fsys.html#sys.builtin_module_names",rel:[l,m,n],target:o},children:[{type:a,value:S}]},{type:a,value:"). Some built-in modules that are commonly included are "},{type:b,tag:c,props:{},children:[{type:a,value:bx}]},{type:a,value:" (always included), "},{type:b,tag:c,props:{},children:[{type:a,value:ak}]},{type:a,value:af},{type:b,tag:c,props:{},children:[{type:a,value:"itertools"}]},{type:a,value:by},{type:b,tag:c,props:{},children:[{type:a,value:"time"}]},{type:a,value:", among others."}]},{type:a,value:d},{type:b,tag:g,props:{},children:[{type:a,value:"Unlike built-in modules which are first in the search path, the rest of the modules in Python's standard library (not built-ins) come after the directory of the current script. This leads to confusing behavior: it is possible to \"replace\" some but not all modules in Python's standard library. For example, on my computer (Windows 10, Python 3.6), the "},{type:b,tag:c,props:{},children:[{type:a,value:ak}]},{type:a,value:" module is a built-in module, whereas the "},{type:b,tag:c,props:{},children:[{type:a,value:bz}]},{type:a,value:" module is not. Thus, "},{type:b,tag:c,props:{},children:[{type:a,value:"import math"}]},{type:a,value:at},{type:b,tag:c,props:{},children:[{type:a,value:z}]},{type:a,value:" will import the "},{type:b,tag:c,props:{},children:[{type:a,value:ak}]},{type:a,value:" module from the standard library, NOT my own "},{type:b,tag:c,props:{},children:[{type:a,value:"math.py"}]},{type:a,value:" file in the same directory. However, "},{type:b,tag:c,props:{},children:[{type:a,value:"import random"}]},{type:a,value:at},{type:b,tag:c,props:{},children:[{type:a,value:z}]},{type:a,value:" will import my "},{type:b,tag:c,props:{},children:[{type:a,value:"random.py"}]},{type:a,value:" file, NOT the "},{type:b,tag:c,props:{},children:[{type:a,value:bz}]},{type:a,value:" module from the standard library."}]},{type:a,value:d},{type:b,tag:g,props:{},children:[{type:a,value:"Also, "},{type:b,tag:C,props:{},children:[{type:a,value:"Python imports are case-sensitive."}]},{type:a,value:s},{type:b,tag:c,props:{},children:[{type:a,value:"import Spam"}]},{type:a,value:" is not the same as "},{type:b,tag:c,props:{},children:[{type:a,value:"import spam"}]},{type:a,value:k}]},{type:a,value:d},{type:b,tag:g,props:{},children:[{type:a,value:"The function "},{type:b,tag:c,props:{},children:[{type:a,value:"pkgutil.iter_modules"}]},{type:a,value:bw},{type:b,tag:j,props:{href:"https:\u002F\u002Fdocs.python.org\u002F2\u002Flibrary\u002Fpkgutil.html#pkgutil.iter_modules",rel:[l,m,n],target:o},children:[{type:a,value:Q}]},{type:a,value:P},{type:b,tag:j,props:{href:"https:\u002F\u002Fdocs.python.org\u002F3\u002Flibrary\u002Fpkgutil.html#pkgutil.iter_modules",rel:[l,m,n],target:o},children:[{type:a,value:S}]},{type:a,value:") can be used to get a list of all importable modules from a given path:"}]},{type:a,value:d},{type:b,tag:H,props:{className:[I]},children:[{type:b,tag:J,props:{className:[K,L]},children:[{type:b,tag:c,props:{},children:[{type:b,tag:e,props:{className:[f,q]},children:[{type:a,value:r}]},{type:a,value:" pkgutil\nsearch_path "},{type:b,tag:e,props:{className:[f,B]},children:[{type:a,value:au}]},{type:a,value:s},{type:b,tag:e,props:{className:[f,G]},children:[{type:a,value:"'.'"}]},{type:a,value:s},{type:b,tag:e,props:{className:[f,al]},children:[{type:a,value:"# set to None to see all modules importable from sys.path"}]},{type:a,value:"\nall_modules "},{type:b,tag:e,props:{className:[f,B]},children:[{type:a,value:au}]},{type:a,value:s},{type:b,tag:e,props:{className:[f,h]},children:[{type:a,value:av}]},{type:a,value:"x"},{type:b,tag:e,props:{className:[f,h]},children:[{type:a,value:av}]},{type:b,tag:e,props:{className:[f,"number"]},children:[{type:a,value:"1"}]},{type:b,tag:e,props:{className:[f,h]},children:[{type:a,value:aw}]},{type:a,value:s},{type:b,tag:e,props:{className:[f,q]},children:[{type:a,value:"for"}]},{type:a,value:" x "},{type:b,tag:e,props:{className:[f,q]},children:[{type:a,value:"in"}]},{type:a,value:" pkgutil"},{type:b,tag:e,props:{className:[f,h]},children:[{type:a,value:k}]},{type:a,value:"iter_modules"},{type:b,tag:e,props:{className:[f,h]},children:[{type:a,value:E}]},{type:a,value:$},{type:b,tag:e,props:{className:[f,B]},children:[{type:a,value:au}]},{type:a,value:"search_path"},{type:b,tag:e,props:{className:[f,h]},children:[{type:a,value:A}]},{type:b,tag:e,props:{className:[f,h]},children:[{type:a,value:aw}]},{type:a,value:d},{type:b,tag:e,props:{className:[f,q]},children:[{type:a,value:am}]},{type:b,tag:e,props:{className:[f,h]},children:[{type:a,value:E}]},{type:a,value:"all_modules"},{type:b,tag:e,props:{className:[f,h]},children:[{type:a,value:A}]},{type:a,value:d}]}]}]},{type:a,value:d},{type:b,tag:g,props:{},children:[{type:b,tag:F,props:{},children:[{type:a,value:ax}]}]},{type:a,value:d},{type:b,tag:t,props:{},children:[{type:a,value:d},{type:b,tag:i,props:{},children:[{type:b,tag:j,props:{href:"https:\u002F\u002Fstackoverflow.com\u002Fq\u002F8370206",rel:[l,m,n],target:o},children:[{type:a,value:"How to get a list of built-in modules in python?"}]}]},{type:a,value:d},{type:b,tag:i,props:{},children:[{type:a,value:"Thank you "},{type:b,tag:j,props:{href:"https:\u002F\u002Fgithub.com\u002Fetene",rel:[l,m,n],target:o},children:[{type:a,value:"etene"}]},{type:a,value:" for pointing out the difference between built-in modules and other modules in Python's standard library (Issue "},{type:b,tag:j,props:{href:"https:\u002F\u002Fgithub.com\u002Fchrisyeh96\u002Fchrisyeh96.github.io\u002Fissues\u002F2",rel:[l,m,n],target:o},children:[{type:a,value:Q}]},{type:a,value:A}]},{type:a,value:d}]},{type:a,value:d},{type:b,tag:T,props:{id:aT},children:[{type:b,tag:j,props:{href:"#more-on-syspath",ariaHidden:u,tabIndex:v},children:[{type:b,tag:e,props:{className:[w,x]},children:[]}]},{type:a,value:"More on "},{type:b,tag:c,props:{},children:[{type:a,value:p}]}]},{type:a,value:d},{type:b,tag:g,props:{},children:[{type:a,value:"To see what is in "},{type:b,tag:c,props:{},children:[{type:a,value:p}]},{type:a,value:", run the following in the interpreter or as a script:"}]},{type:a,value:d},{type:b,tag:H,props:{className:[I]},children:[{type:b,tag:J,props:{className:[K,L]},children:[{type:b,tag:c,props:{},children:[{type:b,tag:e,props:{className:[f,q]},children:[{type:a,value:r}]},{type:a,value:" sys\n"},{type:b,tag:e,props:{className:[f,q]},children:[{type:a,value:am}]},{type:b,tag:e,props:{className:[f,h]},children:[{type:a,value:E}]},{type:a,value:bx},{type:b,tag:e,props:{className:[f,h]},children:[{type:a,value:k}]},{type:a,value:$},{type:b,tag:e,props:{className:[f,h]},children:[{type:a,value:A}]},{type:a,value:d}]}]}]},{type:a,value:d},{type:b,tag:g,props:{},children:[{type:a,value:"Python's documentation for "},{type:b,tag:c,props:{},children:[{type:a,value:p}]},{type:a,value:" describes it as..."}]},{type:a,value:d},{type:b,tag:_,props:{},children:[{type:a,value:d},{type:b,tag:g,props:{},children:[{type:a,value:"A list of strings that specifies the search path for modules. Initialized from the environment variable "},{type:b,tag:c,props:{},children:[{type:a,value:Y}]},{type:a,value:", plus an installation-dependent default."}]},{type:a,value:d},{type:b,tag:g,props:{},children:[{type:a,value:"As initialized upon program startup, the first item of this list, "},{type:b,tag:c,props:{},children:[{type:a,value:bA}]},{type:a,value:", is the directory containing the script that was used to invoke the Python interpreter. If the script directory is not available (e.g. if the interpreter is invoked interactively or if the script is read from standard input), "},{type:b,tag:c,props:{},children:[{type:a,value:bA}]},{type:a,value:" is the empty string, which directs Python to search modules in the current directory first. Notice that the script directory is inserted before the entries inserted as a result of "},{type:b,tag:c,props:{},children:[{type:a,value:Y}]},{type:a,value:k}]},{type:a,value:d},{type:b,tag:g,props:{},children:[{type:b,tag:F,props:{},children:[{type:a,value:aj},{type:b,tag:j,props:{href:"https:\u002F\u002Fdocs.python.org\u002F2\u002Flibrary\u002Fsys.html#sys.path",rel:[l,m,n],target:o},children:[{type:a,value:Q}]},{type:a,value:P},{type:b,tag:j,props:{href:"https:\u002F\u002Fdocs.python.org\u002F3\u002Flibrary\u002Fsys.html#sys.path",rel:[l,m,n],target:o},children:[{type:a,value:S}]}]}]},{type:a,value:d}]},{type:a,value:d},{type:b,tag:g,props:{},children:[{type:a,value:"The documentation for Python's command line interface adds the following about running scripts from the command line. Specifically, when running "},{type:b,tag:c,props:{},children:[{type:a,value:bB}]},{type:a,value:", then..."}]},{type:a,value:d},{type:b,tag:_,props:{},children:[{type:a,value:d},{type:b,tag:g,props:{},children:[{type:a,value:"If the script name refers directly to a Python file, the directory containing that file is added to the start of sys.path, and the file is executed as the "},{type:b,tag:C,props:{},children:[{type:a,value:bC}]},{type:a,value:bD}]},{type:a,value:d},{type:b,tag:g,props:{},children:[{type:b,tag:F,props:{},children:[{type:a,value:aj},{type:b,tag:j,props:{href:"https:\u002F\u002Fdocs.python.org\u002F2\u002Fusing\u002Fcmdline.html",rel:[l,m,n],target:o},children:[{type:a,value:Q}]},{type:a,value:P},{type:b,tag:j,props:{href:"https:\u002F\u002Fdocs.python.org\u002F3\u002Fusing\u002Fcmdline.html",rel:[l,m,n],target:o},children:[{type:a,value:S}]}]}]},{type:a,value:d}]},{type:a,value:d},{type:b,tag:g,props:{},children:[{type:a,value:"Let's recap the order in which Python searches for modules to import:"}]},{type:a,value:d},{type:b,tag:W,props:{},children:[{type:a,value:d},{type:b,tag:i,props:{},children:[{type:a,value:d},{type:b,tag:g,props:{},children:[{type:a,value:"modules in the Python Standard Library (e.g. "},{type:b,tag:c,props:{},children:[{type:a,value:ak}]},{type:a,value:af},{type:b,tag:c,props:{},children:[{type:a,value:an}]},{type:a,value:A}]},{type:a,value:d}]},{type:a,value:d},{type:b,tag:i,props:{},children:[{type:a,value:d},{type:b,tag:g,props:{},children:[{type:a,value:"modules or packages in a directory specified by "},{type:b,tag:c,props:{},children:[{type:a,value:p}]},{type:a,value:aa}]},{type:a,value:d},{type:b,tag:W,props:{},children:[{type:a,value:d},{type:b,tag:i,props:{},children:[{type:a,value:d},{type:b,tag:g,props:{},children:[{type:a,value:"If the Python interpreter is run interactively:"}]},{type:a,value:d},{type:b,tag:t,props:{},children:[{type:a,value:d},{type:b,tag:i,props:{},children:[{type:b,tag:c,props:{},children:[{type:a,value:bE}]},{type:a,value:" is the empty string "},{type:b,tag:c,props:{},children:[{type:a,value:"''"}]},{type:a,value:". This tells Python to search the current working directory from which you launched the interpreter, i.e. the output of "},{type:b,tag:c,props:{},children:[{type:a,value:"pwd"}]},{type:a,value:" on Unix systems."}]},{type:a,value:d}]},{type:a,value:d},{type:b,tag:g,props:{},children:[{type:a,value:"If we run a script with "},{type:b,tag:c,props:{},children:[{type:a,value:bB}]},{type:a,value:aa}]},{type:a,value:d},{type:b,tag:t,props:{},children:[{type:a,value:d},{type:b,tag:i,props:{},children:[{type:b,tag:c,props:{},children:[{type:a,value:bE}]},{type:a,value:" is the path to "},{type:b,tag:c,props:{},children:[{type:a,value:"\u003Cscript\u003E.py"}]}]},{type:a,value:d}]},{type:a,value:d}]},{type:a,value:d},{type:b,tag:i,props:{},children:[{type:a,value:d},{type:b,tag:g,props:{},children:[{type:a,value:"directories in the "},{type:b,tag:c,props:{},children:[{type:a,value:Y}]},{type:a,value:" environment variable"}]},{type:a,value:d}]},{type:a,value:d},{type:b,tag:i,props:{},children:[{type:a,value:d},{type:b,tag:g,props:{},children:[{type:a,value:"default "},{type:b,tag:c,props:{},children:[{type:a,value:p}]},{type:a,value:" locations"}]},{type:a,value:d}]},{type:a,value:d}]},{type:a,value:d}]},{type:a,value:d}]},{type:a,value:d},{type:b,tag:g,props:{},children:[{type:a,value:"Note that "},{type:b,tag:C,props:{},children:[{type:a,value:"when running a Python script, "},{type:b,tag:c,props:{},children:[{type:a,value:p}]},{type:a,value:" doesn't care what your current \"working directory\" is. It only cares about the path to the script"}]},{type:a,value:". For example, if my shell is currently at the "},{type:b,tag:c,props:{},children:[{type:a,value:D}]},{type:a,value:" folder and I run "},{type:b,tag:c,props:{},children:[{type:a,value:"python .\u002FpackA\u002FsubA\u002FsubA1.py"}]},{type:a,value:bF},{type:b,tag:c,props:{},children:[{type:a,value:p}]},{type:a,value:" includes "},{type:b,tag:c,props:{},children:[{type:a,value:"test\u002FpackA\u002FsubA\u002F"}]},{type:a,value:" but NOT "},{type:b,tag:c,props:{},children:[{type:a,value:D}]},{type:a,value:k}]},{type:a,value:d},{type:b,tag:g,props:{},children:[{type:a,value:"Additionally, "},{type:b,tag:c,props:{},children:[{type:a,value:p}]},{type:a,value:" is shared across all imported modules. For example, suppose we call "},{type:b,tag:c,props:{},children:[{type:a,value:ay}]},{type:a,value:". Let "},{type:b,tag:c,props:{},children:[{type:a,value:z}]},{type:a,value:" import "},{type:b,tag:c,props:{},children:[{type:a,value:"packA.a1"}]},{type:a,value:", and let "},{type:b,tag:c,props:{},children:[{type:a,value:U}]},{type:a,value:" print out "},{type:b,tag:c,props:{},children:[{type:a,value:p}]},{type:a,value:". Then "},{type:b,tag:c,props:{},children:[{type:a,value:p}]},{type:a,value:" will include "},{type:b,tag:c,props:{},children:[{type:a,value:D}]},{type:a,value:bG},{type:b,tag:c,props:{},children:[{type:a,value:z}]},{type:a,value:"), but NOT "},{type:b,tag:c,props:{},children:[{type:a,value:ab}]},{type:a,value:bG},{type:b,tag:c,props:{},children:[{type:a,value:U}]},{type:a,value:"). What this means is that "},{type:b,tag:c,props:{},children:[{type:a,value:U}]},{type:a,value:" can call "},{type:b,tag:c,props:{},children:[{type:a,value:"import other"}]},{type:a,value:" since "},{type:b,tag:c,props:{},children:[{type:a,value:"other.py"}]},{type:a,value:" is a file in "},{type:b,tag:c,props:{},children:[{type:a,value:D}]},{type:a,value:k}]},{type:a,value:d},{type:b,tag:O,props:{id:aU},children:[{type:b,tag:j,props:{href:"#all-about-__init__py",ariaHidden:u,tabIndex:v},children:[{type:b,tag:e,props:{className:[w,x]},children:[]}]},{type:a,value:"All about "},{type:b,tag:c,props:{},children:[{type:a,value:y}]}]},{type:a,value:d},{type:b,tag:g,props:{},children:[{type:a,value:bH},{type:b,tag:c,props:{},children:[{type:a,value:y}]},{type:a,value:" file has 2 functions."}]},{type:a,value:d},{type:b,tag:W,props:{},children:[{type:a,value:d},{type:b,tag:i,props:{},children:[{type:a,value:"convert a folder of scripts into an importable package of modules (before Python 3.3)"}]},{type:a,value:d},{type:b,tag:i,props:{},children:[{type:a,value:"run package initialization code"}]},{type:a,value:d}]},{type:a,value:d},{type:b,tag:T,props:{id:aV},children:[{type:b,tag:j,props:{href:"#converting-a-folder-of-scripts-into-an-importable-package-of-modules",ariaHidden:u,tabIndex:v},children:[{type:b,tag:e,props:{className:[w,x]},children:[]}]},{type:a,value:aW}]},{type:a,value:d},{type:b,tag:g,props:{},children:[{type:a,value:"In order to import a module or package from a directory that is not in the same directory as the script we are writing (or the directory from which we run the Python interactive interpreter), that module needs to be in a package."}]},{type:a,value:d},{type:b,tag:g,props:{},children:[{type:a,value:"As defined above, any directory with a file named "},{type:b,tag:c,props:{},children:[{type:a,value:y}]},{type:a,value:" is a Python package. This file can be empty. For example, when running Python 2.7, "},{type:b,tag:c,props:{},children:[{type:a,value:z}]},{type:a,value:" can import the package "},{type:b,tag:c,props:{},children:[{type:a,value:ao}]},{type:a,value:" but not "},{type:b,tag:c,props:{},children:[{type:a,value:ap}]},{type:a,value:" because there is no "},{type:b,tag:c,props:{},children:[{type:a,value:y}]},{type:a,value:" file in the "},{type:b,tag:c,props:{},children:[{type:a,value:"test\u002FpackB\u002F"}]},{type:a,value:" directory."}]},{type:a,value:d},{type:b,tag:g,props:{},children:[{type:a,value:"This does NOT apply to Python 3.3 and above, thanks to the adoption of implicit namespace packages. Basically, Python 3.3+ treats all folders as packages, so empty "},{type:b,tag:c,props:{},children:[{type:a,value:y}]},{type:a,value:" files are no longer necessary and can be omitted."}]},{type:a,value:d},{type:b,tag:g,props:{},children:[{type:a,value:"For example, "},{type:b,tag:c,props:{},children:[{type:a,value:ap}]},{type:a,value:" is a namespace package because it doesn't have a "},{type:b,tag:c,props:{},children:[{type:a,value:y}]},{type:a,value:" file in the folder. If we start a Python 3.6 interactive interpreter in the "},{type:b,tag:c,props:{},children:[{type:a,value:D}]},{type:a,value:" directory, then we get the following output:"}]},{type:a,value:d},{type:b,tag:H,props:{className:[I]},children:[{type:b,tag:J,props:{className:[K,L]},children:[{type:b,tag:c,props:{},children:[{type:b,tag:e,props:{className:[f,B]},children:[{type:a,value:ac}]},{type:b,tag:e,props:{className:[f,B]},children:[{type:a,value:X}]},{type:a,value:s},{type:b,tag:e,props:{className:[f,q]},children:[{type:a,value:r}]},{type:a,value:bI},{type:b,tag:e,props:{className:[f,B]},children:[{type:a,value:ac}]},{type:b,tag:e,props:{className:[f,B]},children:[{type:a,value:X}]},{type:a,value:bI},{type:b,tag:e,props:{className:[f,B]},children:[{type:a,value:bJ}]},{type:a,value:bK},{type:b,tag:e,props:{className:[f,G]},children:[{type:a,value:"'packB'"}]},{type:a,value:s},{type:b,tag:e,props:{className:[f,h]},children:[{type:a,value:E}]},{type:a,value:"namespace"},{type:b,tag:e,props:{className:[f,h]},children:[{type:a,value:A}]},{type:b,tag:e,props:{className:[f,B]},children:[{type:a,value:X}]},{type:a,value:d}]}]}]},{type:a,value:d},{type:b,tag:g,props:{},children:[{type:b,tag:F,props:{},children:[{type:a,value:ax}]}]},{type:a,value:d},{type:b,tag:W,props:{},children:[{type:a,value:d},{type:b,tag:i,props:{},children:[{type:b,tag:j,props:{href:"https:\u002F\u002Fstackoverflow.com\u002Fq\u002F448271",rel:[l,m,n],target:o},children:[{type:a,value:"What is "},{type:b,tag:C,props:{},children:[{type:a,value:"init"}]},{type:a,value:".py for?"}]}]},{type:a,value:d},{type:b,tag:i,props:{},children:[{type:b,tag:j,props:{href:"https:\u002F\u002Fwww.python.org\u002Fdev\u002Fpeps\u002Fpep-0420\u002F",rel:[l,m,n],target:o},children:[{type:a,value:"PEP 420: Implicit Namespace Packages"}]}]},{type:a,value:d}]},{type:a,value:d},{type:b,tag:T,props:{id:aX},children:[{type:b,tag:j,props:{href:"#running-package-initialization-code",ariaHidden:u,tabIndex:v},children:[{type:b,tag:e,props:{className:[w,x]},children:[]}]},{type:a,value:aY}]},{type:a,value:d},{type:b,tag:g,props:{},children:[{type:a,value:"The first time that a package or one of its modules is imported, Python will execute the "},{type:b,tag:c,props:{},children:[{type:a,value:y}]},{type:a,value:" file in the root folder of the package if the file exists. All objects and functions defined in "},{type:b,tag:c,props:{},children:[{type:a,value:y}]},{type:a,value:" are considered part of the package namespace."}]},{type:a,value:d},{type:b,tag:g,props:{},children:[{type:a,value:"Consider the following example."}]},{type:a,value:d},{type:b,tag:g,props:{},children:[{type:b,tag:c,props:{},children:[{type:a,value:"test\u002FpackA\u002Fa1.py"}]}]},{type:a,value:d},{type:b,tag:H,props:{className:[I]},children:[{type:b,tag:J,props:{className:[K,L]},children:[{type:b,tag:c,props:{},children:[{type:b,tag:e,props:{className:[f,q]},children:[{type:a,value:bL}]},{type:a,value:s},{type:b,tag:e,props:{className:[f,bM]},children:[{type:a,value:az}]},{type:b,tag:e,props:{className:[f,h]},children:[{type:a,value:E}]},{type:b,tag:e,props:{className:[f,h]},children:[{type:a,value:A}]},{type:b,tag:e,props:{className:[f,h]},children:[{type:a,value:aa}]},{type:a,value:bN},{type:b,tag:e,props:{className:[f,q]},children:[{type:a,value:am}]},{type:b,tag:e,props:{className:[f,h]},children:[{type:a,value:E}]},{type:b,tag:e,props:{className:[f,G]},children:[{type:a,value:"\"running a1_func()\""}]},{type:b,tag:e,props:{className:[f,h]},children:[{type:a,value:A}]},{type:a,value:d}]}]}]},{type:a,value:d},{type:b,tag:g,props:{},children:[{type:b,tag:c,props:{},children:[{type:a,value:bO}]}]},{type:a,value:d},{type:b,tag:H,props:{className:[I]},children:[{type:b,tag:J,props:{className:[K,L]},children:[{type:b,tag:c,props:{},children:[{type:b,tag:e,props:{className:[f,al]},children:[{type:a,value:"## this import makes a1_func directly accessible from packA.a1_func"}]},{type:a,value:d},{type:b,tag:e,props:{className:[f,q]},children:[{type:a,value:ad}]},{type:a,value:ag},{type:b,tag:e,props:{className:[f,h]},children:[{type:a,value:k}]},{type:a,value:"a1 "},{type:b,tag:e,props:{className:[f,q]},children:[{type:a,value:r}]},{type:a,value:" a1_func\n\n"},{type:b,tag:e,props:{className:[f,q]},children:[{type:a,value:bL}]},{type:a,value:s},{type:b,tag:e,props:{className:[f,bM]},children:[{type:a,value:bP}]},{type:b,tag:e,props:{className:[f,h]},children:[{type:a,value:E}]},{type:b,tag:e,props:{className:[f,h]},children:[{type:a,value:A}]},{type:b,tag:e,props:{className:[f,h]},children:[{type:a,value:aa}]},{type:a,value:bN},{type:b,tag:e,props:{className:[f,q]},children:[{type:a,value:am}]},{type:b,tag:e,props:{className:[f,h]},children:[{type:a,value:E}]},{type:b,tag:e,props:{className:[f,G]},children:[{type:a,value:"\"running packA_func()\""}]},{type:b,tag:e,props:{className:[f,h]},children:[{type:a,value:A}]},{type:a,value:d}]}]}]},{type:a,value:d},{type:b,tag:g,props:{},children:[{type:b,tag:c,props:{},children:[{type:a,value:"test\u002Fstart.py"}]}]},{type:a,value:d},{type:b,tag:H,props:{className:[I]},children:[{type:b,tag:J,props:{className:[K,L]},children:[{type:b,tag:c,props:{},children:[{type:b,tag:e,props:{className:[f,q]},children:[{type:a,value:r}]},{type:a,value:" packA  "},{type:b,tag:e,props:{className:[f,al]},children:[{type:a,value:"# \"import packA.a1\" will work just the same"}]},{type:a,value:"\n\npackA"},{type:b,tag:e,props:{className:[f,h]},children:[{type:a,value:k}]},{type:a,value:bP},{type:b,tag:e,props:{className:[f,h]},children:[{type:a,value:E}]},{type:b,tag:e,props:{className:[f,h]},children:[{type:a,value:A}]},{type:a,value:bQ},{type:b,tag:e,props:{className:[f,h]},children:[{type:a,value:k}]},{type:a,value:az},{type:b,tag:e,props:{className:[f,h]},children:[{type:a,value:E}]},{type:b,tag:e,props:{className:[f,h]},children:[{type:a,value:A}]},{type:a,value:bQ},{type:b,tag:e,props:{className:[f,h]},children:[{type:a,value:k}]},{type:a,value:bR},{type:b,tag:e,props:{className:[f,h]},children:[{type:a,value:k}]},{type:a,value:az},{type:b,tag:e,props:{className:[f,h]},children:[{type:a,value:E}]},{type:b,tag:e,props:{className:[f,h]},children:[{type:a,value:A}]},{type:a,value:d}]}]}]},{type:a,value:d},{type:b,tag:g,props:{},children:[{type:a,value:"output of running "},{type:b,tag:c,props:{},children:[{type:a,value:ay}]},{type:a,value:aa}]},{type:a,value:d},{type:b,tag:H,props:{className:[I]},children:[{type:b,tag:J,props:{className:[K,br]},children:[{type:b,tag:c,props:{},children:[{type:a,value:"running packA_func()\nrunning a1_func()\nrunning a1_func()\n"}]}]}]},{type:a,value:d},{type:b,tag:g,props:{},children:[{type:a,value:"*Note: if "},{type:b,tag:c,props:{},children:[{type:a,value:U}]},{type:a,value:" calls "},{type:b,tag:c,props:{},children:[{type:a,value:"import a2"}]},{type:a,value:" and we run "},{type:b,tag:c,props:{},children:[{type:a,value:"python a1.py"}]},{type:a,value:bF},{type:b,tag:c,props:{},children:[{type:a,value:bO}]},{type:a,value:" will NOT be called, even though it seems like "},{type:b,tag:c,props:{},children:[{type:a,value:ah}]},{type:a,value:" is part of the "},{type:b,tag:c,props:{},children:[{type:a,value:ao}]},{type:a,value:" package. This is because when Python runs a script (in this case "},{type:b,tag:c,props:{},children:[{type:a,value:U}]},{type:a,value:"), its containing folder is not considered a package."}]},{type:a,value:d},{type:b,tag:O,props:{id:aZ},children:[{type:b,tag:j,props:{href:"#using-objects-from-the-imported-module-or-package",ariaHidden:u,tabIndex:v},children:[{type:b,tag:e,props:{className:[w,x]},children:[]}]},{type:a,value:a_}]},{type:a,value:d},{type:b,tag:g,props:{},children:[{type:a,value:"There are 4 different syntaxes for writing import statements."}]},{type:a,value:d},{type:b,tag:W,props:{},children:[{type:a,value:d},{type:b,tag:i,props:{},children:[{type:b,tag:c,props:{},children:[{type:a,value:"import \u003Cpackage\u003E"}]}]},{type:a,value:d},{type:b,tag:i,props:{},children:[{type:b,tag:c,props:{},children:[{type:a,value:"import \u003Cmodule\u003E"}]}]},{type:a,value:d},{type:b,tag:i,props:{},children:[{type:b,tag:c,props:{},children:[{type:a,value:"from \u003Cpackage\u003E import \u003Cmodule or subpackage or object\u003E"}]}]},{type:a,value:d},{type:b,tag:i,props:{},children:[{type:b,tag:c,props:{},children:[{type:a,value:"from \u003Cmodule\u003E import \u003Cobject\u003E"}]}]},{type:a,value:d}]},{type:a,value:d},{type:b,tag:g,props:{},children:[{type:a,value:"Let "},{type:b,tag:c,props:{},children:[{type:a,value:Z}]},{type:a,value:" be whatever name comes after "},{type:b,tag:c,props:{},children:[{type:a,value:r}]},{type:a,value:k}]},{type:a,value:d},{type:b,tag:t,props:{},children:[{type:a,value:d},{type:b,tag:i,props:{},children:[{type:a,value:aA},{type:b,tag:c,props:{},children:[{type:a,value:Z}]},{type:a,value:" is the name of a module or package, then to use objects defined in "},{type:b,tag:c,props:{},children:[{type:a,value:Z}]},{type:a,value:", you have to write "},{type:b,tag:c,props:{},children:[{type:a,value:"X.object"}]},{type:a,value:k}]},{type:a,value:d},{type:b,tag:i,props:{},children:[{type:a,value:aA},{type:b,tag:c,props:{},children:[{type:a,value:Z}]},{type:a,value:" is a variable name, then it can be used directly."}]},{type:a,value:d},{type:b,tag:i,props:{},children:[{type:a,value:aA},{type:b,tag:c,props:{},children:[{type:a,value:Z}]},{type:a,value:" is a function name, then it can be invoked with "},{type:b,tag:c,props:{},children:[{type:a,value:"X()"}]}]},{type:a,value:d}]},{type:a,value:d},{type:b,tag:g,props:{},children:[{type:a,value:"Optionally, "},{type:b,tag:c,props:{},children:[{type:a,value:"as Y"}]},{type:a,value:" can be added after any "},{type:b,tag:c,props:{},children:[{type:a,value:"import X"}]},{type:a,value:" statement: "},{type:b,tag:c,props:{},children:[{type:a,value:"import X as Y"}]},{type:a,value:". This renames "},{type:b,tag:c,props:{},children:[{type:a,value:Z}]},{type:a,value:" to "},{type:b,tag:c,props:{},children:[{type:a,value:"Y"}]},{type:a,value:" within the script. Note that the name "},{type:b,tag:c,props:{},children:[{type:a,value:Z}]},{type:a,value:" itself is no longer valid. A common example is "},{type:b,tag:c,props:{},children:[{type:a,value:"import numpy as np"}]},{type:a,value:k}]},{type:a,value:d},{type:b,tag:g,props:{},children:[{type:a,value:"The argument to the "},{type:b,tag:c,props:{},children:[{type:a,value:r}]},{type:a,value:" function can be a single name, or a list of multiple names. Each of these names can be optionally renamed via "},{type:b,tag:c,props:{},children:[{type:a,value:"as"}]},{type:a,value:". For example, this is would be a valid import statement in "},{type:b,tag:c,props:{},children:[{type:a,value:z}]},{type:a,value:": "},{type:b,tag:c,props:{},children:[{type:a,value:"import packA as pA, packA.a1, packA.subA.sa1 as sa1"}]}]},{type:a,value:d},{type:b,tag:g,props:{},children:[{type:a,value:"Example: "},{type:b,tag:c,props:{},children:[{type:a,value:z}]},{type:a,value:" needs to import the "},{type:b,tag:c,props:{},children:[{type:a,value:aB}]},{type:a,value:bS},{type:b,tag:c,props:{},children:[{type:a,value:ai}]}]},{type:a,value:d},{type:b,tag:t,props:{},children:[{type:a,value:d},{type:b,tag:i,props:{},children:[{type:a,value:"Solution 1: "},{type:b,tag:c,props:{},children:[{type:a,value:bT}]},{type:b,tag:t,props:{},children:[{type:a,value:d},{type:b,tag:i,props:{},children:[{type:a,value:"we can call the function directly by name: "},{type:b,tag:c,props:{},children:[{type:a,value:"x = helloWorld()"}]}]},{type:a,value:d}]}]},{type:a,value:d},{type:b,tag:i,props:{},children:[{type:a,value:"Solution 2: "},{type:b,tag:c,props:{},children:[{type:a,value:"from packA.subA import sa1"}]},{type:a,value:" or equivalently "},{type:b,tag:c,props:{},children:[{type:a,value:"import packA.subA.sa1 as sa1"}]},{type:b,tag:t,props:{},children:[{type:a,value:d},{type:b,tag:i,props:{},children:[{type:a,value:"we have to prefix the function name with the name of the module: "},{type:b,tag:c,props:{},children:[{type:a,value:"x = sa1.helloWorld()"}]}]},{type:a,value:d},{type:b,tag:i,props:{},children:[{type:a,value:"This is sometimes preferred over Solution 1 in order to make it explicit that we are calling the "},{type:b,tag:c,props:{},children:[{type:a,value:bU}]},{type:a,value:" function from the "},{type:b,tag:c,props:{},children:[{type:a,value:aq}]},{type:a,value:bD}]},{type:a,value:d}]}]},{type:a,value:d},{type:b,tag:i,props:{},children:[{type:a,value:"Solution 3: "},{type:b,tag:c,props:{},children:[{type:a,value:"import packA.subA.sa1"}]},{type:a,value:k},{type:b,tag:t,props:{},children:[{type:a,value:d},{type:b,tag:i,props:{},children:[{type:a,value:"we need to use the full path: "},{type:b,tag:c,props:{},children:[{type:a,value:"x = packA.subA.sa1.helloWorld()"}]}]},{type:a,value:d}]}]},{type:a,value:d}]},{type:a,value:d},{type:b,tag:T,props:{id:a$},children:[{type:b,tag:j,props:{href:"#use-dir-to-examine-the-contents-of-an-imported-module",ariaHidden:u,tabIndex:v},children:[{type:b,tag:e,props:{className:[w,x]},children:[]}]},{type:a,value:"Use "},{type:b,tag:c,props:{},children:[{type:a,value:bV}]},{type:a,value:" to examine the contents of an imported module"}]},{type:a,value:d},{type:b,tag:g,props:{},children:[{type:a,value:"After importing a module, use the "},{type:b,tag:c,props:{},children:[{type:a,value:bV}]},{type:a,value:" function to get a list of accessible names from the module. For example, suppose I import "},{type:b,tag:c,props:{},children:[{type:a,value:aq}]},{type:a,value:". If "},{type:b,tag:c,props:{},children:[{type:a,value:ai}]},{type:a,value:" defines a "},{type:b,tag:c,props:{},children:[{type:a,value:aB}]},{type:a,value:" function, then "},{type:b,tag:c,props:{},children:[{type:a,value:"dir(sa1)"}]},{type:a,value:" would include "},{type:b,tag:c,props:{},children:[{type:a,value:bU}]},{type:a,value:k}]},{type:a,value:d},{type:b,tag:H,props:{className:[I]},children:[{type:b,tag:J,props:{className:[K,L]},children:[{type:b,tag:c,props:{},children:[{type:b,tag:e,props:{className:[f,B]},children:[{type:a,value:ac}]},{type:b,tag:e,props:{className:[f,B]},children:[{type:a,value:X}]},{type:a,value:s},{type:b,tag:e,props:{className:[f,q]},children:[{type:a,value:ad}]},{type:a,value:ag},{type:b,tag:e,props:{className:[f,h]},children:[{type:a,value:k}]},{type:a,value:aC},{type:b,tag:e,props:{className:[f,q]},children:[{type:a,value:r}]},{type:a,value:bW},{type:b,tag:e,props:{className:[f,B]},children:[{type:a,value:ac}]},{type:b,tag:e,props:{className:[f,B]},children:[{type:a,value:X}]},{type:a,value:s},{type:b,tag:e,props:{className:[f,"builtin"]},children:[{type:a,value:"dir"}]},{type:b,tag:e,props:{className:[f,h]},children:[{type:a,value:E}]},{type:a,value:aq},{type:b,tag:e,props:{className:[f,h]},children:[{type:a,value:A}]},{type:a,value:d},{type:b,tag:e,props:{className:[f,h]},children:[{type:a,value:av}]},{type:b,tag:e,props:{className:[f,G]},children:[{type:a,value:"'__builtins__'"}]},{type:b,tag:e,props:{className:[f,h]},children:[{type:a,value:V}]},{type:a,value:s},{type:b,tag:e,props:{className:[f,G]},children:[{type:a,value:"'__cached__'"}]},{type:b,tag:e,props:{className:[f,h]},children:[{type:a,value:V}]},{type:a,value:s},{type:b,tag:e,props:{className:[f,G]},children:[{type:a,value:"'__doc__'"}]},{type:b,tag:e,props:{className:[f,h]},children:[{type:a,value:V}]},{type:a,value:s},{type:b,tag:e,props:{className:[f,G]},children:[{type:a,value:"'__file__'"}]},{type:b,tag:e,props:{className:[f,h]},children:[{type:a,value:V}]},{type:a,value:s},{type:b,tag:e,props:{className:[f,G]},children:[{type:a,value:"'__loader__'"}]},{type:b,tag:e,props:{className:[f,h]},children:[{type:a,value:V}]},{type:a,value:s},{type:b,tag:e,props:{className:[f,G]},children:[{type:a,value:"'__name__'"}]},{type:b,tag:e,props:{className:[f,h]},children:[{type:a,value:V}]},{type:a,value:s},{type:b,tag:e,props:{className:[f,G]},children:[{type:a,value:"'__package__'"}]},{type:b,tag:e,props:{className:[f,h]},children:[{type:a,value:V}]},{type:a,value:s},{type:b,tag:e,props:{className:[f,G]},children:[{type:a,value:"'__spec__'"}]},{type:b,tag:e,props:{className:[f,h]},children:[{type:a,value:V}]},{type:a,value:s},{type:b,tag:e,props:{className:[f,G]},children:[{type:a,value:"'helloWorld'"}]},{type:b,tag:e,props:{className:[f,h]},children:[{type:a,value:aw}]},{type:a,value:d}]}]}]},{type:a,value:d},{type:b,tag:T,props:{id:ba},children:[{type:b,tag:j,props:{href:"#importing-packages",ariaHidden:u,tabIndex:v},children:[{type:b,tag:e,props:{className:[w,x]},children:[]}]},{type:a,value:bb}]},{type:a,value:d},{type:b,tag:g,props:{},children:[{type:a,value:"Importing a package is conceptually equivalent to importing the package's "},{type:b,tag:c,props:{},children:[{type:a,value:y}]},{type:a,value:" file as a module. Indeed, this is what Python treats the package as:"}]},{type:a,value:d},{type:b,tag:H,props:{className:[I]},children:[{type:b,tag:J,props:{className:[K,L]},children:[{type:b,tag:c,props:{},children:[{type:b,tag:e,props:{className:[f,B]},children:[{type:a,value:ac}]},{type:b,tag:e,props:{className:[f,B]},children:[{type:a,value:X}]},{type:a,value:s},{type:b,tag:e,props:{className:[f,q]},children:[{type:a,value:r}]},{type:a,value:bX},{type:b,tag:e,props:{className:[f,B]},children:[{type:a,value:ac}]},{type:b,tag:e,props:{className:[f,B]},children:[{type:a,value:X}]},{type:a,value:bX},{type:b,tag:e,props:{className:[f,B]},children:[{type:a,value:bJ}]},{type:a,value:bK},{type:b,tag:e,props:{className:[f,G]},children:[{type:a,value:"'packA'"}]},{type:a,value:s},{type:b,tag:e,props:{className:[f,q]},children:[{type:a,value:ad}]},{type:a,value:s},{type:b,tag:e,props:{className:[f,G]},children:[{type:a,value:"'packA\\__init__.py'"}]},{type:b,tag:e,props:{className:[f,B]},children:[{type:a,value:X}]},{type:a,value:d}]}]}]},{type:a,value:d},{type:b,tag:g,props:{},children:[{type:a,value:"Only objects declared in the imported package's "},{type:b,tag:c,props:{},children:[{type:a,value:y}]},{type:a,value:" are accessible to the importer. For example, since "},{type:b,tag:c,props:{},children:[{type:a,value:ap}]},{type:a,value:" lacks a "},{type:b,tag:c,props:{},children:[{type:a,value:y}]},{type:a,value:" file, calling "},{type:b,tag:c,props:{},children:[{type:a,value:"import packB"}]},{type:a,value:" (in Python 3.3+) has very little use because no objects in the "},{type:b,tag:c,props:{},children:[{type:a,value:ap}]},{type:a,value:" package are made available. A subsequent call to "},{type:b,tag:c,props:{},children:[{type:a,value:"packB.b1"}]},{type:a,value:" would fail because it has not been imported yet."}]},{type:a,value:d},{type:b,tag:O,props:{id:bc},children:[{type:b,tag:j,props:{href:"#absolute-vs-relative-import",ariaHidden:u,tabIndex:v},children:[{type:b,tag:e,props:{className:[w,x]},children:[]}]},{type:a,value:bd}]},{type:a,value:d},{type:b,tag:g,props:{},children:[{type:a,value:bH},{type:b,tag:C,props:{},children:[{type:a,value:"absolute import"}]},{type:a,value:" uses the full path (starting from the project's root folder) to the desired module to import."}]},{type:a,value:d},{type:b,tag:g,props:{},children:[{type:a,value:"A "},{type:b,tag:C,props:{},children:[{type:a,value:"relative import"}]},{type:a,value:" uses the relative path (starting from the path of the current module) to the desired module to import. There are two types of relative imports:"}]},{type:a,value:d},{type:b,tag:t,props:{},children:[{type:a,value:d},{type:b,tag:i,props:{},children:[{type:a,value:bY},{type:b,tag:F,props:{},children:[{type:a,value:"explicit"}]},{type:a,value:" relative import follows the format "},{type:b,tag:c,props:{},children:[{type:a,value:"from .\u003Cmodule\u002Fpackage\u003E import X"}]},{type:a,value:", where "},{type:b,tag:c,props:{},children:[{type:a,value:"\u003Cmodule\u002Fpackage\u003E"}]},{type:a,value:" is prefixed by dots "},{type:b,tag:c,props:{},children:[{type:a,value:k}]},{type:a,value:" that indicate how many directories upwards to traverse. A single dot "},{type:b,tag:c,props:{},children:[{type:a,value:k}]},{type:a,value:" corresponds to the current directory; two dots "},{type:b,tag:c,props:{},children:[{type:a,value:".."}]},{type:a,value:" indicate one folder up; etc."}]},{type:a,value:d},{type:b,tag:i,props:{},children:[{type:a,value:bY},{type:b,tag:F,props:{},children:[{type:a,value:"implicit"}]},{type:a,value:" relative import is written as if the current directory is part of "},{type:b,tag:c,props:{},children:[{type:a,value:p}]},{type:a,value:bv},{type:b,tag:C,props:{},children:[{type:a,value:"Implicit relative imports are only supported in Python 2. They are NOT SUPPORTED IN PYTHON 3."}]}]},{type:a,value:d}]},{type:a,value:d},{type:b,tag:g,props:{},children:[{type:a,value:"The Python documentation says the following about Python 3's handling of relative imports:"}]},{type:a,value:d},{type:b,tag:_,props:{},children:[{type:a,value:d},{type:b,tag:g,props:{},children:[{type:a,value:"The only acceptable syntax for relative imports is from .[module] import name. All import forms not starting with . are interpreted as absolute imports."}]},{type:a,value:d},{type:b,tag:g,props:{},children:[{type:a,value:"Source: "},{type:b,tag:j,props:{href:bZ,rel:[l,m,n],target:o},children:[{type:a,value:b_}]}]},{type:a,value:d}]},{type:a,value:d},{type:b,tag:g,props:{},children:[{type:a,value:"For example, suppose we are running "},{type:b,tag:c,props:{},children:[{type:a,value:z}]},{type:a,value:" which imports "},{type:b,tag:c,props:{},children:[{type:a,value:bR}]},{type:a,value:" which in turn imports "},{type:b,tag:c,props:{},children:[{type:a,value:"other"}]},{type:a,value:af},{type:b,tag:c,props:{},children:[{type:a,value:ah}]},{type:a,value:by},{type:b,tag:c,props:{},children:[{type:a,value:aq}]},{type:a,value:". Then the import statements in "},{type:b,tag:c,props:{},children:[{type:a,value:U}]},{type:a,value:" would look as follows:"}]},{type:a,value:d},{type:b,tag:t,props:{},children:[{type:a,value:d},{type:b,tag:i,props:{},children:[{type:a,value:d},{type:b,tag:g,props:{},children:[{type:a,value:"absolute imports:"}]},{type:a,value:d},{type:b,tag:H,props:{className:[I]},children:[{type:b,tag:J,props:{className:[K,L]},children:[{type:b,tag:c,props:{},children:[{type:b,tag:e,props:{className:[f,q]},children:[{type:a,value:r}]},{type:a,value:aD},{type:b,tag:e,props:{className:[f,q]},children:[{type:a,value:r}]},{type:a,value:ag},{type:b,tag:e,props:{className:[f,h]},children:[{type:a,value:k}]},{type:a,value:"a2\n"},{type:b,tag:e,props:{className:[f,q]},children:[{type:a,value:r}]},{type:a,value:ag},{type:b,tag:e,props:{className:[f,h]},children:[{type:a,value:k}]},{type:a,value:aE},{type:b,tag:e,props:{className:[f,h]},children:[{type:a,value:k}]},{type:a,value:b$}]}]}]},{type:a,value:d}]},{type:a,value:d},{type:b,tag:i,props:{},children:[{type:a,value:d},{type:b,tag:g,props:{},children:[{type:a,value:"explicit relative imports:"}]},{type:a,value:d},{type:b,tag:H,props:{className:[I]},children:[{type:b,tag:J,props:{className:[K,L]},children:[{type:b,tag:c,props:{},children:[{type:b,tag:e,props:{className:[f,q]},children:[{type:a,value:r}]},{type:a,value:aD},{type:b,tag:e,props:{className:[f,q]},children:[{type:a,value:ad}]},{type:a,value:s},{type:b,tag:e,props:{className:[f,h]},children:[{type:a,value:k}]},{type:a,value:s},{type:b,tag:e,props:{className:[f,q]},children:[{type:a,value:r}]},{type:a,value:ca},{type:b,tag:e,props:{className:[f,q]},children:[{type:a,value:ad}]},{type:a,value:s},{type:b,tag:e,props:{className:[f,h]},children:[{type:a,value:k}]},{type:a,value:aC},{type:b,tag:e,props:{className:[f,q]},children:[{type:a,value:r}]},{type:a,value:bW}]}]}]},{type:a,value:d}]},{type:a,value:d},{type:b,tag:i,props:{},children:[{type:a,value:d},{type:b,tag:g,props:{},children:[{type:a,value:"implicit relative imports (NOT SUPPORTED IN PYTHON 3):"}]},{type:a,value:d},{type:b,tag:H,props:{className:[I]},children:[{type:b,tag:J,props:{className:[K,L]},children:[{type:b,tag:c,props:{},children:[{type:b,tag:e,props:{className:[f,q]},children:[{type:a,value:r}]},{type:a,value:aD},{type:b,tag:e,props:{className:[f,q]},children:[{type:a,value:r}]},{type:a,value:ca},{type:b,tag:e,props:{className:[f,q]},children:[{type:a,value:r}]},{type:a,value:" subA"},{type:b,tag:e,props:{className:[f,h]},children:[{type:a,value:k}]},{type:a,value:b$}]}]}]},{type:a,value:d}]},{type:a,value:d}]},{type:a,value:d},{type:b,tag:g,props:{},children:[{type:a,value:"Note that for relative imports, the dots "},{type:b,tag:c,props:{},children:[{type:a,value:k}]},{type:a,value:" can go up only up to (but not including) the directory containing the script run from the command line. Thus, "},{type:b,tag:c,props:{},children:[{type:a,value:"from .. import other"}]},{type:a,value:" is invalid in "},{type:b,tag:c,props:{},children:[{type:a,value:U}]},{type:a,value:". Doing so results in the error "},{type:b,tag:c,props:{},children:[{type:a,value:cb}]},{type:a,value:k}]},{type:a,value:d},{type:b,tag:g,props:{},children:[{type:a,value:"In general, absolute imports are preferred over relative imports. They avoid the confusion between explicit vs. implicit relative imports. In addition, any script that uses explicit relative imports cannot be run directly:"}]},{type:a,value:d},{type:b,tag:_,props:{},children:[{type:a,value:d},{type:b,tag:g,props:{},children:[{type:a,value:"Note that relative imports are based on the name of the current module. Since the name of the main module is always \""},{type:b,tag:C,props:{},children:[{type:a,value:bC}]},{type:a,value:"\", modules intended for use as the main module of a Python application must always use absolute imports."}]},{type:a,value:d},{type:b,tag:g,props:{},children:[{type:b,tag:F,props:{},children:[{type:a,value:aj},{type:b,tag:j,props:{href:cc,rel:[l,m,n],target:o},children:[{type:a,value:Q}]},{type:a,value:P},{type:b,tag:j,props:{href:cd,rel:[l,m,n],target:o},children:[{type:a,value:S}]}]}]},{type:a,value:d}]},{type:a,value:d},{type:b,tag:g,props:{},children:[{type:b,tag:F,props:{},children:[{type:a,value:ax}]}]},{type:a,value:d},{type:b,tag:t,props:{},children:[{type:a,value:d},{type:b,tag:i,props:{},children:[{type:b,tag:j,props:{href:"https:\u002F\u002Fstackoverflow.com\u002Fq\u002F4655526",rel:[l,m,n],target:o},children:[{type:a,value:"How to accomplish relative import in python"}]}]},{type:a,value:d},{type:b,tag:i,props:{},children:[{type:b,tag:j,props:{href:ce,rel:[l,m,n],target:o},children:[{type:a,value:cf}]}]},{type:a,value:d}]},{type:a,value:d},{type:b,tag:O,props:{id:be},children:[{type:b,tag:j,props:{href:"#case-examples",ariaHidden:u,tabIndex:v},children:[{type:b,tag:e,props:{className:[w,x]},children:[]}]},{type:a,value:bf}]},{type:a,value:d},{type:b,tag:T,props:{id:bg},children:[{type:b,tag:j,props:{href:"#case-1-syspath-is-known-ahead-of-time",ariaHidden:u,tabIndex:v},children:[{type:b,tag:e,props:{className:[w,x]},children:[]}]},{type:a,value:"Case 1: "},{type:b,tag:c,props:{},children:[{type:a,value:p}]},{type:a,value:" is known ahead of time"}]},{type:a,value:d},{type:b,tag:g,props:{},children:[{type:a,value:"If you only ever call "},{type:b,tag:c,props:{},children:[{type:a,value:ay}]},{type:a,value:cg},{type:b,tag:c,props:{},children:[{type:a,value:"python other.py"}]},{type:a,value:", then it is very easy to set up the imports for all of the modules. In this case, "},{type:b,tag:c,props:{},children:[{type:a,value:p}]},{type:a,value:" will always include "},{type:b,tag:c,props:{},children:[{type:a,value:D}]},{type:a,value:" in its search path. Therefore, all of the import statements can be written relative to the "},{type:b,tag:c,props:{},children:[{type:a,value:D}]},{type:a,value:bs}]},{type:a,value:d},{type:b,tag:g,props:{},children:[{type:a,value:"Ex: a file in the "},{type:b,tag:c,props:{},children:[{type:a,value:"test"}]},{type:a,value:" project needs to import the "},{type:b,tag:c,props:{},children:[{type:a,value:aB}]},{type:a,value:bS},{type:b,tag:c,props:{},children:[{type:a,value:ai}]}]},{type:a,value:d},{type:b,tag:t,props:{},children:[{type:a,value:d},{type:b,tag:i,props:{},children:[{type:a,value:"Solution: "},{type:b,tag:c,props:{},children:[{type:a,value:bT}]},{type:a,value:" (or any of the other equivalent import syntaxes demonstrated above)"}]},{type:a,value:d}]},{type:a,value:d},{type:b,tag:T,props:{id:bh},children:[{type:b,tag:j,props:{href:"#case-2-syspath-could-change",ariaHidden:u,tabIndex:v},children:[{type:b,tag:e,props:{className:[w,x]},children:[]}]},{type:a,value:"Case 2: "},{type:b,tag:c,props:{},children:[{type:a,value:p}]},{type:a,value:" could change"}]},{type:a,value:d},{type:b,tag:g,props:{},children:[{type:a,value:"Often, we want to be flexible in how we use a Python script, whether run directly on the command line or imported as a module into another script. As shown below, this is where we run into problems, especially on Python 3."}]},{type:a,value:d},{type:b,tag:g,props:{},children:[{type:b,tag:C,props:{},children:[{type:a,value:"Example"}]},{type:a,value:": Suppose "},{type:b,tag:c,props:{},children:[{type:a,value:z}]},{type:a,value:" needs to import "},{type:b,tag:c,props:{},children:[{type:a,value:ah}]},{type:a,value:" which needs to import "},{type:b,tag:c,props:{},children:[{type:a,value:ch}]},{type:a,value:". Assume that "},{type:b,tag:c,props:{},children:[{type:a,value:z}]},{type:a,value:" is always run directly, never imported. We also want to be able to run "},{type:b,tag:c,props:{},children:[{type:a,value:ah}]},{type:a,value:" on its own."}]},{type:a,value:d},{type:b,tag:g,props:{},children:[{type:b,tag:F,props:{},children:[{type:a,value:"Seems easy enough, right? After all, we just need 2 import statements total: 1 in "},{type:b,tag:c,props:{},children:[{type:a,value:z}]},{type:a,value:" and another in "},{type:b,tag:c,props:{},children:[{type:a,value:M}]},{type:a,value:k}]}]},{type:a,value:d},{type:b,tag:g,props:{},children:[{type:b,tag:C,props:{},children:[{type:a,value:"Problem"}]},{type:a,value:": This is clearly a case where "},{type:b,tag:c,props:{},children:[{type:a,value:p}]},{type:a,value:" changes. When we run "},{type:b,tag:c,props:{},children:[{type:a,value:z}]},{type:a,value:af},{type:b,tag:c,props:{},children:[{type:a,value:p}]},{type:a,value:ar},{type:b,tag:c,props:{},children:[{type:a,value:D}]},{type:a,value:". When we run "},{type:b,tag:c,props:{},children:[{type:a,value:M}]},{type:a,value:af},{type:b,tag:c,props:{},children:[{type:a,value:p}]},{type:a,value:ar},{type:b,tag:c,props:{},children:[{type:a,value:ab}]},{type:a,value:k}]},{type:a,value:d},{type:b,tag:g,props:{},children:[{type:a,value:ci},{type:b,tag:c,props:{},children:[{type:a,value:z}]},{type:a,value:" is easy. Since "},{type:b,tag:c,props:{},children:[{type:a,value:z}]},{type:a,value:" it is always run directly and never imported, we know that "},{type:b,tag:c,props:{},children:[{type:a,value:D}]},{type:a,value:" will always be in "},{type:b,tag:c,props:{},children:[{type:a,value:p}]},{type:a,value:" when it is run. Then importing "},{type:b,tag:c,props:{},children:[{type:a,value:ah}]},{type:a,value:" is simply "},{type:b,tag:c,props:{},children:[{type:a,value:"import packA.a2"}]},{type:a,value:k}]},{type:a,value:d},{type:b,tag:g,props:{},children:[{type:a,value:ci},{type:b,tag:c,props:{},children:[{type:a,value:M}]},{type:a,value:" is trickier. When we run "},{type:b,tag:c,props:{},children:[{type:a,value:z}]},{type:a,value:" directly, "},{type:b,tag:c,props:{},children:[{type:a,value:p}]},{type:a,value:ar},{type:b,tag:c,props:{},children:[{type:a,value:D}]},{type:a,value:", so "},{type:b,tag:c,props:{},children:[{type:a,value:M}]},{type:a,value:" should call "},{type:b,tag:c,props:{},children:[{type:a,value:aF}]},{type:a,value:". However, if we instead run "},{type:b,tag:c,props:{},children:[{type:a,value:M}]},{type:a,value:" directly, then "},{type:b,tag:c,props:{},children:[{type:a,value:p}]},{type:a,value:ar},{type:b,tag:c,props:{},children:[{type:a,value:ab}]},{type:a,value:". Now the import would fail because "},{type:b,tag:c,props:{},children:[{type:a,value:ao}]},{type:a,value:" is not a folder inside "},{type:b,tag:c,props:{},children:[{type:a,value:ab}]},{type:a,value:k}]},{type:a,value:d},{type:b,tag:g,props:{},children:[{type:a,value:"Instead, we could try "},{type:b,tag:c,props:{},children:[{type:a,value:cj}]},{type:a,value:". This corrects the problem when we run "},{type:b,tag:c,props:{},children:[{type:a,value:M}]},{type:a,value:" directly. But now we have a problem when we run "},{type:b,tag:c,props:{},children:[{type:a,value:z}]},{type:a,value:" directly. Under Python 3, this fails because "},{type:b,tag:c,props:{},children:[{type:a,value:aE}]},{type:a,value:" is not in "},{type:b,tag:c,props:{},children:[{type:a,value:p}]},{type:a,value:". (This is OK in Python 2, thanks to its support for implicit relative imports.)"}]},{type:a,value:d},{type:b,tag:g,props:{},children:[{type:a,value:"Let's summarize our findings about the import statement in "},{type:b,tag:c,props:{},children:[{type:a,value:M}]},{type:a,value:aa}]},{type:a,value:"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"},{type:b,tag:"table",props:{},children:[{type:b,tag:"thead",props:{},children:[{type:b,tag:aG,props:{},children:[{type:b,tag:aH,props:{},children:[{type:a,value:"Run"}]},{type:b,tag:aH,props:{},children:[{type:b,tag:c,props:{},children:[{type:a,value:aF}]}]},{type:b,tag:aH,props:{},children:[{type:b,tag:c,props:{},children:[{type:a,value:cj}]}]}]}]},{type:b,tag:"tbody",props:{},children:[{type:b,tag:aG,props:{},children:[{type:b,tag:ae,props:{},children:[{type:b,tag:c,props:{},children:[{type:a,value:z}]}]},{type:b,tag:ae,props:{},children:[{type:a,value:ck}]},{type:b,tag:ae,props:{},children:[{type:a,value:"Py2 OK, Py3 fail ("},{type:b,tag:c,props:{},children:[{type:a,value:aE}]},{type:a,value:cl},{type:b,tag:c,props:{},children:[{type:a,value:D}]},{type:a,value:A}]}]},{type:b,tag:aG,props:{},children:[{type:b,tag:ae,props:{},children:[{type:b,tag:c,props:{},children:[{type:a,value:M}]}]},{type:b,tag:ae,props:{},children:[{type:a,value:"fail ("},{type:b,tag:c,props:{},children:[{type:a,value:ao}]},{type:a,value:cl},{type:b,tag:c,props:{},children:[{type:a,value:ab}]},{type:a,value:A}]},{type:b,tag:ae,props:{},children:[{type:a,value:ck}]}]}]}]},{type:a,value:d},{type:b,tag:g,props:{},children:[{type:a,value:"For completeness sake, I also tried using relative imports: "},{type:b,tag:c,props:{},children:[{type:a,value:"from .subA import sa2"}]},{type:a,value:". This matches the result of "},{type:b,tag:c,props:{},children:[{type:a,value:aF}]},{type:a,value:k}]},{type:a,value:d},{type:b,tag:g,props:{},children:[{type:b,tag:C,props:{},children:[{type:a,value:"Solutions (Workarounds)"}]},{type:a,value:": I am unaware of a clean solution to this problem. Here are some workarounds:"}]},{type:a,value:d},{type:b,tag:W,props:{},children:[{type:a,value:d},{type:b,tag:i,props:{},children:[{type:a,value:d},{type:b,tag:g,props:{},children:[{type:a,value:aI},{type:b,tag:c,props:{},children:[{type:a,value:D}]},{type:a,value:cm},{type:b,tag:c,props:{},children:[{type:a,value:z}]},{type:a,value:cn},{type:b,tag:c,props:{},children:[{type:a,value:M}]},{type:a,value:" directly, run it as an imported module instead of as a script:"}]},{type:a,value:d},{type:b,tag:W,props:{},children:[{type:a,value:d},{type:b,tag:i,props:{},children:[{type:a,value:"change directories to "},{type:b,tag:c,props:{},children:[{type:a,value:D}]},{type:a,value:" in the console"}]},{type:a,value:d},{type:b,tag:i,props:{},children:[{type:b,tag:c,props:{},children:[{type:a,value:"python -m packA.a2"}]}]},{type:a,value:d}]},{type:a,value:d}]},{type:a,value:d},{type:b,tag:i,props:{},children:[{type:a,value:d},{type:b,tag:g,props:{},children:[{type:a,value:aI},{type:b,tag:c,props:{},children:[{type:a,value:D}]},{type:a,value:cm},{type:b,tag:c,props:{},children:[{type:a,value:z}]},{type:a,value:cn},{type:b,tag:c,props:{},children:[{type:a,value:M}]},{type:a,value:" directly, we can modify "},{type:b,tag:c,props:{},children:[{type:a,value:p}]},{type:a,value:at},{type:b,tag:c,props:{},children:[{type:a,value:M}]},{type:a,value:" to include "},{type:b,tag:c,props:{},children:[{type:a,value:ab}]},{type:a,value:", before "},{type:b,tag:c,props:{},children:[{type:a,value:ch}]},{type:a,value:" is imported."}]},{type:a,value:d},{type:b,tag:H,props:{className:[I]},children:[{type:b,tag:J,props:{className:[K,L]},children:[{type:b,tag:c,props:{},children:[{type:b,tag:e,props:{className:[f,q]},children:[{type:a,value:r}]},{type:a,value:" os"},{type:b,tag:e,props:{className:[f,h]},children:[{type:a,value:V}]},{type:a,value:" sys\nsys"},{type:b,tag:e,props:{className:[f,h]},children:[{type:a,value:k}]},{type:a,value:$},{type:b,tag:e,props:{className:[f,h]},children:[{type:a,value:k}]},{type:a,value:"append"},{type:b,tag:e,props:{className:[f,h]},children:[{type:a,value:E}]},{type:a,value:an},{type:b,tag:e,props:{className:[f,h]},children:[{type:a,value:k}]},{type:a,value:$},{type:b,tag:e,props:{className:[f,h]},children:[{type:a,value:k}]},{type:a,value:co},{type:b,tag:e,props:{className:[f,h]},children:[{type:a,value:E}]},{type:a,value:an},{type:b,tag:e,props:{className:[f,h]},children:[{type:a,value:k}]},{type:a,value:$},{type:b,tag:e,props:{className:[f,h]},children:[{type:a,value:k}]},{type:a,value:co},{type:b,tag:e,props:{className:[f,h]},children:[{type:a,value:E}]},{type:a,value:an},{type:b,tag:e,props:{className:[f,h]},children:[{type:a,value:k}]},{type:a,value:$},{type:b,tag:e,props:{className:[f,h]},children:[{type:a,value:k}]},{type:a,value:"realpath"},{type:b,tag:e,props:{className:[f,h]},children:[{type:a,value:E}]},{type:a,value:cp},{type:b,tag:e,props:{className:[f,h]},children:[{type:a,value:A}]},{type:b,tag:e,props:{className:[f,h]},children:[{type:a,value:A}]},{type:b,tag:e,props:{className:[f,h]},children:[{type:a,value:A}]},{type:b,tag:e,props:{className:[f,h]},children:[{type:a,value:A}]},{type:a,value:"\n\n"},{type:b,tag:e,props:{className:[f,al]},children:[{type:a,value:"# now this works, even when a2.py is run directly"}]},{type:a,value:d},{type:b,tag:e,props:{className:[f,q]},children:[{type:a,value:ad}]},{type:a,value:ag},{type:b,tag:e,props:{className:[f,h]},children:[{type:a,value:k}]},{type:a,value:aC},{type:b,tag:e,props:{className:[f,q]},children:[{type:a,value:r}]},{type:a,value:" sa2\n"}]}]}]},{type:a,value:d},{type:b,tag:g,props:{},children:[{type:a,value:"NOTE: This method usually works. However, under some Python installations, the "},{type:b,tag:c,props:{},children:[{type:a,value:cp}]},{type:a,value:" variable might not be correct. In this case, we would need to use the Python built-in "},{type:b,tag:c,props:{},children:[{type:a,value:"inspect"}]},{type:a,value:" package. See "},{type:b,tag:j,props:{href:"https:\u002F\u002Fstackoverflow.com\u002Fa\u002F11158224",rel:[l,m,n],target:o},children:[{type:a,value:"this StackOverflow answer"}]},{type:a,value:" for instructions."}]},{type:a,value:d}]},{type:a,value:d},{type:b,tag:i,props:{},children:[{type:a,value:d},{type:b,tag:g,props:{},children:[{type:a,value:"Only use Python 2, and use implicit relative imports (i.e. the right column in the table above)"}]},{type:a,value:d}]},{type:a,value:d},{type:b,tag:i,props:{},children:[{type:a,value:d},{type:b,tag:g,props:{},children:[{type:a,value:aI},{type:b,tag:c,props:{},children:[{type:a,value:D}]},{type:a,value:" directory, and add "},{type:b,tag:c,props:{},children:[{type:a,value:D}]},{type:a,value:" to the "},{type:b,tag:c,props:{},children:[{type:a,value:Y}]},{type:a,value:" environment variable."}]},{type:a,value:d},{type:b,tag:t,props:{},children:[{type:a,value:d},{type:b,tag:i,props:{},children:[{type:a,value:"This solution is not portable, so I recommend against it."}]},{type:a,value:d},{type:b,tag:i,props:{},children:[{type:a,value:"instructions here: "},{type:b,tag:j,props:{href:"https:\u002F\u002Fstackoverflow.com\u002Fq\u002F3402168",rel:[l,m,n],target:o},children:[{type:a,value:"Permanently add a directory to PYTHONPATH"}]}]},{type:a,value:d}]},{type:a,value:d}]},{type:a,value:d}]},{type:a,value:d},{type:b,tag:T,props:{id:bi},children:[{type:b,tag:j,props:{href:"#case-3-syspath-could-change-take-2",ariaHidden:u,tabIndex:v},children:[{type:b,tag:e,props:{className:[w,x]},children:[]}]},{type:a,value:"Case 3: "},{type:b,tag:c,props:{},children:[{type:a,value:p}]},{type:a,value:" could change (take 2)"}]},{type:a,value:d},{type:b,tag:g,props:{},children:[{type:a,value:"A harder problem to deal with is the following example. Suppose "},{type:b,tag:c,props:{},children:[{type:a,value:M}]},{type:a,value:" never needs to be run directly, but it is imported by both "},{type:b,tag:c,props:{},children:[{type:a,value:z}]},{type:a,value:P},{type:b,tag:c,props:{},children:[{type:a,value:U}]},{type:a,value:" which are run directly."}]},{type:a,value:d},{type:b,tag:g,props:{},children:[{type:a,value:"In this case, using "},{type:b,tag:F,props:{},children:[{type:a,value:"Solution 1"}]},{type:a,value:" described above won't work. However, the other solutions are still valid."}]},{type:a,value:d},{type:b,tag:T,props:{id:bj},children:[{type:b,tag:j,props:{href:"#case-4-importing-from-parent-directory",ariaHidden:u,tabIndex:v},children:[{type:b,tag:e,props:{className:[w,x]},children:[]}]},{type:a,value:bk}]},{type:a,value:d},{type:b,tag:g,props:{},children:[{type:a,value:"If we do not modify "},{type:b,tag:c,props:{},children:[{type:a,value:Y}]},{type:a,value:" and avoid modifying "},{type:b,tag:c,props:{},children:[{type:a,value:p}]},{type:a,value:" programmatically, then the following is a major limitation of Python imports:"}]},{type:a,value:d},{type:b,tag:g,props:{},children:[{type:b,tag:C,props:{},children:[{type:a,value:"When running a script directly, it is impossible to import anything from its parent directory."}]}]},{type:a,value:d},{type:b,tag:g,props:{},children:[{type:a,value:"For example, if I were to run "},{type:b,tag:c,props:{},children:[{type:a,value:"python sa1.py"}]},{type:a,value:", then it is impossible for"},{type:b,tag:c,props:{},children:[{type:a,value:ai}]},{type:a,value:" to import anything from "},{type:b,tag:c,props:{},children:[{type:a,value:U}]},{type:a,value:" without resorting to a "},{type:b,tag:c,props:{},children:[{type:a,value:Y}]},{type:a,value:cg},{type:b,tag:c,props:{},children:[{type:a,value:p}]},{type:a,value:" workaround."}]},{type:a,value:d},{type:b,tag:g,props:{},children:[{type:a,value:"At first, it may seem that relative imports (e.g. "},{type:b,tag:c,props:{},children:[{type:a,value:"from .. import a1"}]},{type:a,value:") could work around this limitation. However, the script that is being run (in this case "},{type:b,tag:c,props:{},children:[{type:a,value:ai}]},{type:a,value:") is considered the \"top-level module.\" Attempting to import anything from a folder above this script results in this error: "},{type:b,tag:c,props:{},children:[{type:a,value:cb}]},{type:a,value:k}]},{type:a,value:d},{type:b,tag:g,props:{},children:[{type:a,value:"My approach is to avoid writing scripts that have to import from the parent directory. In cases where this must happen, the preferred workaround is to modify "},{type:b,tag:c,props:{},children:[{type:a,value:p}]},{type:a,value:k}]},{type:a,value:d},{type:b,tag:O,props:{id:bl},children:[{type:b,tag:j,props:{href:"#python-2-vs-python-3",ariaHidden:u,tabIndex:v},children:[{type:b,tag:e,props:{className:[w,x]},children:[]}]},{type:a,value:bm}]},{type:a,value:d},{type:b,tag:g,props:{},children:[{type:a,value:"The most important differences between how Python 2 and Python 3 treat "},{type:b,tag:c,props:{},children:[{type:a,value:r}]},{type:a,value:" statements have been documented above. They are re-stated again here, along with some other less important differences."}]},{type:a,value:d},{type:b,tag:W,props:{},children:[{type:a,value:d},{type:b,tag:i,props:{},children:[{type:a,value:"Python 2 supports implicit relative imports. Python 3 does not."}]},{type:a,value:d},{type:b,tag:i,props:{},children:[{type:a,value:"Python 2 requires "},{type:b,tag:c,props:{},children:[{type:a,value:y}]},{type:a,value:" files inside a folder in order for the folder to be considered a package and made importable. In Python 3.3 and above, thanks to its support of implicit namespace packages, all folders are packages regardless of the presence of a "},{type:b,tag:c,props:{},children:[{type:a,value:y}]},{type:a,value:bq}]},{type:a,value:d},{type:b,tag:i,props:{},children:[{type:a,value:"In Python 2, one could write "},{type:b,tag:c,props:{},children:[{type:a,value:as}]},{type:a,value:" within a function. In Python 3, the "},{type:b,tag:c,props:{},children:[{type:a,value:as}]},{type:a,value:" syntax is only allowed at the module level, no longer inside functions."}]},{type:a,value:d}]},{type:a,value:d},{type:b,tag:g,props:{},children:[{type:a,value:"Sources:"}]},{type:a,value:d},{type:b,tag:t,props:{},children:[{type:a,value:d},{type:b,tag:i,props:{},children:[{type:b,tag:j,props:{href:ce,rel:[l,m,n],target:o},children:[{type:a,value:cf}]}]},{type:a,value:d},{type:b,tag:i,props:{},children:[{type:b,tag:j,props:{href:cc,rel:[l,m,n],target:o},children:[{type:a,value:"Python 2 modules documentation"}]}]},{type:a,value:d},{type:b,tag:i,props:{},children:[{type:b,tag:j,props:{href:cd,rel:[l,m,n],target:o},children:[{type:a,value:"Python 3 modules documentation"}]}]},{type:a,value:d},{type:b,tag:i,props:{},children:[{type:b,tag:j,props:{href:bZ,rel:[l,m,n],target:o},children:[{type:a,value:b_}]}]},{type:a,value:d}]},{type:a,value:d},{type:b,tag:O,props:{id:bn},children:[{type:b,tag:j,props:{href:"#miscellaneous-topics-and-readings-not-covered-here-but-worth-exploring",ariaHidden:u,tabIndex:v},children:[{type:b,tag:e,props:{className:[w,x]},children:[]}]},{type:a,value:bo}]},{type:a,value:d},{type:b,tag:t,props:{},children:[{type:a,value:d},{type:b,tag:i,props:{},children:[{type:a,value:cq},{type:b,tag:c,props:{},children:[{type:a,value:"__all__"}]},{type:a,value:" variable in "},{type:b,tag:c,props:{},children:[{type:a,value:y}]},{type:a,value:" for specifying what gets imported by "},{type:b,tag:c,props:{},children:[{type:a,value:as}]},{type:b,tag:t,props:{},children:[{type:a,value:d},{type:b,tag:i,props:{},children:[{type:a,value:aJ},{type:b,tag:j,props:{href:"https:\u002F\u002Fdocs.python.org\u002F2\u002Ftutorial\u002Fmodules.html#importing-from-a-package",rel:[l,m,n],target:o},children:[{type:a,value:Q}]},{type:a,value:P},{type:b,tag:j,props:{href:"https:\u002F\u002Fdocs.python.org\u002F3\u002Ftutorial\u002Fmodules.html#importing-from-a-package",rel:[l,m,n],target:o},children:[{type:a,value:S}]}]},{type:a,value:d}]}]},{type:a,value:d},{type:b,tag:i,props:{},children:[{type:a,value:cq},{type:b,tag:c,props:{},children:[{type:a,value:"if __name__ == '__main__'"}]},{type:a,value:" to check if a script is imported or run directly"},{type:b,tag:t,props:{},children:[{type:a,value:d},{type:b,tag:i,props:{},children:[{type:a,value:aJ},{type:b,tag:j,props:{href:"https:\u002F\u002Fdocs.python.org\u002F2\u002Flibrary\u002F__main__.html",rel:[l,m,n],target:o},children:[{type:a,value:Q}]},{type:a,value:P},{type:b,tag:j,props:{href:"https:\u002F\u002Fdocs.python.org\u002F3\u002Flibrary\u002F__main__.html",rel:[l,m,n],target:o},children:[{type:a,value:S}]}]},{type:a,value:d}]}]},{type:a,value:d},{type:b,tag:i,props:{},children:[{type:a,value:"installing a project as a package (in developer mode) with "},{type:b,tag:c,props:{},children:[{type:a,value:"pip install -e \u003Cproject\u003E"}]},{type:a,value:" to add the project root directory to "},{type:b,tag:c,props:{},children:[{type:a,value:p}]},{type:b,tag:t,props:{},children:[{type:a,value:d},{type:b,tag:i,props:{},children:[{type:b,tag:j,props:{href:"https:\u002F\u002Fstackoverflow.com\u002Fq\u002F23984973",rel:[l,m,n],target:o},children:[{type:a,value:"How to run tests without installing package?"}]}]},{type:a,value:d}]}]},{type:a,value:d},{type:b,tag:i,props:{},children:[{type:b,tag:c,props:{},children:[{type:a,value:as}]},{type:a,value:" does not import names from "},{type:b,tag:c,props:{},children:[{type:a,value:"\u003Cmodule\u003E"}]},{type:a,value:" that begin with an underscore "},{type:b,tag:c,props:{},children:[{type:a,value:"_"}]},{type:b,tag:t,props:{},children:[{type:a,value:d},{type:b,tag:i,props:{},children:[{type:a,value:aJ},{type:b,tag:j,props:{href:"https:\u002F\u002Fdocs.python.org\u002F2\u002Ftutorial\u002Fmodules.html#more-on-modules",rel:[l,m,n],target:o},children:[{type:a,value:Q}]},{type:a,value:P},{type:b,tag:j,props:{href:"https:\u002F\u002Fdocs.python.org\u002F3\u002Ftutorial\u002Fmodules.html#more-on-modules",rel:[l,m,n],target:o},children:[{type:a,value:S}]}]},{type:a,value:d}]}]},{type:a,value:d}]}]},dir:"\u002Farticles",path:"\u002Farticles\u002Fdefinitive-guide-python-imports",extension:".md",slug:"definitive-guide-python-imports"}}],fetch:[],mutations:void 0}}("text","element","code","\n","span","token","p","punctuation","li","a",".","nofollow","noopener","noreferrer","_blank","sys.path","keyword","import"," ","ul","true",-1,"icon","icon-link","__init__.py","start.py",")","operator","strong","test\u002F","(","em","string","div","nuxt-content-highlight","pre","line-numbers","language-python","a2.py",2,"h2"," and ","2",3,"3","h3","a1.py",",","ol","\u003E","PYTHONPATH","X","blockquote","path",":","test\u002FpackA\u002F","\u003E\u003E","from","td",", "," packA","a2","sa1.py","Source: Python ","math","comment","print","os","packA","packB","sa1"," contains ","from \u003Cmodule\u003E import *"," in ","=","[","]","Sources","python start.py","a1_func","If ","helloWorld()","subA "," other\n","subA","from packA.subA import sa2","tr","th","Use absolute imports rooted at the ","documentation for Python ",true,"summary--key-points","Summary \u002F Key Points","basic-definitions","Basic Definitions","example-directory-structure","Example Directory Structure","what-is-an-import","basics-of-the-python-import-and-syspath","more-on-syspath","all-about-__init__py","converting-a-folder-of-scripts-into-an-importable-package-of-modules","Converting a folder of scripts into an importable package of modules","running-package-initialization-code","Running package initialization code","using-objects-from-the-imported-module-or-package","Using Objects from the Imported Module or Package","use-dir-to-examine-the-contents-of-an-imported-module","importing-packages","Importing Packages","absolute-vs-relative-import","Absolute vs. Relative Import","case-examples","Case Examples","case-1-syspath-is-known-ahead-of-time","case-2-syspath-could-change","case-3-syspath-could-change-take-2","case-4-importing-from-parent-directory","Case 4: Importing from Parent Directory","python-2-vs-python-3","Python 2 vs. Python 3","miscellaneous-topics-and-readings-not-covered-here-but-worth-exploring","Miscellaneous topics and readings not covered here, but worth exploring","*.py"," file.","language-text"," folder.","spam","spam.py",". "," (Python ","sys",", and ","random","path[0]","python \u003Cscript\u003E.py","main"," module.","sys.path[0]",", then "," (the path to ","An "," packB\n","\u003C","module ","def","function","\n    ","test\u002FpackA\u002F__init__.py","packA_func","\npackA","a1"," function in ","from packA.subA.sa1 import helloWorld","helloWorld","dir()"," sa1\n"," packA\n","an ","https:\u002F\u002Fdocs.python.org\u002F3.0\u002Fwhatsnew\u002F3.0.html","What's New in Python 3.0","sa1\n"," a2\n","ValueError: attempted relative import beyond top-level package","https:\u002F\u002Fdocs.python.org\u002F2\u002Ftutorial\u002Fmodules.html#intra-package-references","https:\u002F\u002Fdocs.python.org\u002F3\u002Ftutorial\u002Fmodules.html#intra-package-references","https:\u002F\u002Fstackoverflow.com\u002Fq\u002F12172791","Changes in import statement python3"," or ","sa2","The import statement in ","from subA import sa2","OK"," not in "," directory (i.e. middle column in the table above). This guarantees that running "," directly will always work. In order to run ","dirname","__file__","using ")));